# HashData 数据库的并发控制

HashData 数据库使用PostgreSQL多版本并发控制\(MVCC\)模型 管理并发事务堆表。

数据库管理系统中的并发控制允许并发查询完成 与正确的结果同时确保数据库的完整性。 传统数据库使用 两阶段锁协议,阻止一个事务读取修改数据 由另一个并发事务和阅读或阻止任何并发事务 写数据,另一个事务已经更新。 协调所需的锁 事务争用添加到数据库,减少总体事务吞吐量。

Greenplum数据库使用PostgreSQL多版本并发控制\(MVCC\)模型 管理堆表的并发性。 MVCC,每个查询操作的快照 数据库查询开始时。 虽然执行,查询无法看到其他所做的更改 并发事务。 这可以确保数据库的查询看到一致的视图。 查询读行永远不能阻止等待事务写行。 相反, 查询写行不能被事务读行。 这允许多 并发性比传统数据库系统采用锁协调访问 之间的事务读取和写入数据。

注意:

Append-optimized表管理不同的并发控制模型 MVCC模型中讨论这个话题。 他们的目的是“写一次读多次”应用程序 从来没有或只有很少,执行行级更新。

## 快照

MVCC模型取决于系统的能力来管理多个版本的数据行。 一个 查询操作数据库的快照查询的开始。 是一个快照 组行,可见在声明或事务的开始。 快照 确保有一个一致的和有效的视图的查询数据库的持续时间 执行。

每个事务被分配一个唯一的_事务ID_\(XID\),一个递增32位 价值。 当开始一个新的事务,它分配下一个XID。 这是一个SQL语句 不是封闭在一个事务中被当作一个单独的语句事务中,开始和提交隐式地添加。 这是类似的 在某些数据库系统自动提交。

注意:

Greenplum数据库分配XID值只涉及DDL和DML的事务 操作,这通常是唯一的交易需要一个XID。

当一个事务插入一行,XID保存的行xmin系统列。 当一个事务删除一行,保存在XID 的xmax系统列。 更新一行被当作一个删除一个 插入,所以XID保存到xmax当前行和xmin新插入的行。 的xmin和xmax列,加上事务完成状态,指定一个 事务范围的版本的行是可见的。 一个事务可以看到 不到的所有事务的影响xmin,这是保证 承诺,但不能看到任何交易的影响大于或等于xmax。

Multi-statement交易还必须记录在事务插入的命令 行\(cmin\)或删除一行\(cmax\),这样的事务 先前的命令可以看到更改的事务。 命令序列 期间相关事务,所以序列的开始复位为0 事务。

XID是一个属性的数据库。 每个部分的数据库都有自己的XID序列 不能比其他部分的xid数据库。 主坐标 使用集群范围的分布式事务的片段_会话ID号码_, 被称为gp\_session\_id。 段维护分布式映射 与当地的xid事务id。 主坐标分布式事务 在所有段的两阶段提交协议。 如果对任何事务失败 一个段,回滚段。

你可以看到

xmin

,

xmax

,

cmin

,

cmax

行与列

选择

声明:

```
SELECT xmin, xmax, cmin, cmax, * FROM 
tablename
;
```

因为你运行选择命令在主,xid是 分布式事务id。 如果你能执行命令在一个单独的部分 数据库,xmin和xmax将部分的值 当地的xid。

## 事务ID概括

MVCC模型使用事务id\(xid\)来确定哪些行是可见的 一个查询或事务的开始。 XID是一个32位的值,所以数据库 理论上执行超过四十亿交易价值溢出和包装之前 零。 然而,Greenplum数据库使用_模232_算术xid, 它允许事务id环绕,在十二点钟包装。 对于任何给定的XID,可能有大约二十亿过去XID,二十亿将来XID。 这是之前版本的行持续通过大约二十亿交易,当它 突然似乎是一个新行。 为了防止这样的情况发生,Greenplum有一个特殊的XID,叫做FrozenXID,它一直被认为是比任何常规XID 与之相比。 的xmin行必须更换FrozenXID在二十亿个事务,这是其中一个 函数的真空命令执行。

用真空吸尘器清理数据库至少每二十亿个事务防止XID概括。 Greenplum数据库监视事务ID和警告说如果真空操作是必需的。

一个警告时发出很大一部分的事务id不再 可用之前,事务ID概括 发生:

```
WARNING: database "
database_name
" must be vacuumed within 
number_of_transactions
 transactions
```

当发出警告时,真空操作是必需的。 如果一个真空操作没有执行,Greenplum停止创建数据库 交易,以避免可能的数据丢失,当它到达极限之前,当事务 这个错误ID的发生和问题:

```
FATAL: database is not accepting commands to avoid wraparound data loss in database "
database_name
"
```

看到从事务ID限制错误中恢复恢复的过程 从这个错误。

服务器配置参数xid\_warn\_limit和xid\_stop\_limit控制显示警告和错误。 的xid\_warn\_limit参数指定数量的事务id 的xid\_stop\_limit当发出的警告。 的xid\_stop\_limit参数指定数量的事务id 概括会发生错误时无法创建发布和新事务。

## 事务隔离模式

SQL标准描述了三个现象可以发生在数据库事务运行 同时:

* _脏读_
  ——一个从另一个并发事务可以读取未提交的数据 事务。
* _不可重复读_
  ——连续读两次在一个事务可以改变,因为 另一个事务开始后并发事务提交更改。
* _幻像读_
  ——查询执行两次相同的事务可以返回两个 因为另外一个并发事务不同的行添加行。

SQL标准定义了四种事务隔离模式,数据库系统必须的 支持:

|  |  |  |  |
| :--- | :--- | :--- | :--- |
| 水平 | 脏读 | 不可重复 | 幻像读 |
| 读未提交 | 可能的 | 可能的 | 可能的 |
| 读过承诺 | 不可能的 | 可能的 | 可能的 |
| 可重复读取 | 不可能的 | 不可能的 | 可能的 |
| 可序列化的 | 不可能的 | 不可能的 | 不可能的 |

Greenplum数据库SQL命令允许你请求读未提交,读过承诺,或可序列化的。 Greenplum数据库 对待读未提交一样的读过承诺。 请求可重复读取产生一个错误;使用可序列化的代替。 默认的隔离模式读 承诺。

之间的区别读过承诺和可序列化的是 ,在读过承诺模式中,每个语句在事务中只能看到行 之前的承诺_声明_开始,而在可序列化的模式, 所有语句在事务中只看到行承诺之前_事务_开始了。

的读过承诺隔离模式允许更大的并发性和更好的 性能比可序列化的模式。 它允许_不可重复 读取_,连续两次检索值在一个事务可以因为不同 另一个事务开始之后的并发事务已经提交更改。读过承诺模式还允许_幻读_,一个查询 执行两次在同一事务可以返回两组不同的行。

的可序列化的防止不可重复读和隔离模式 幻读,但并发的成本和性能。 每个并发事务 数据库的一致视图已经开始执行。 一个并发 试图修改数据修改的事务被另一个事务回滚。 应用程序执行交易可序列化的模式必须 准备处理由于序列化错误而失败的事务。 如果可序列化的隔离模式应用程序不是必需的,它是 更好的使用读过承诺模式。

SQL标准指定并发serializable事务产生相同的 如果顺序执行数据库状态会产生。 MVCC快照隔离 模型可以防止脏读、不可重复读和虚读不贵 锁定,但还有其他之间可能发生的相互作用可序列化的Greenplum数据库中事务,阻止他们 真正的可序列化的。 这些异常通常可以归因于Greenplum的事实 数据库不执行_谓词锁定_,这意味着在一个写 事务可以影响以前读的结果在另外一个并发事务。

事务并发运行不应该检查识别交互 预防相同的禁止并发更新数据。 问题确认可以 避免使用显式的表锁或要求冲突的事务 更新一个假行介绍给代表的冲突。

SQL

设置事务隔离级别

声明中设置隔离模式 对当前事务。 之前必须设置模式

选择

,

插入

,

删除

,

更新

,或

复制

声明:

```
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
...
COMMIT;

```

隔离模式也可以指定的一部分

开始

声明:

```
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

默认的事务隔离模式通过设置可以改变一个会话default\_transaction\_isolation配置属性。

## 把死行从表

更新或删除一行离开过期版本的表中的行。 当一个 行到期不再引用的任何活动事务,它可以和删除 空间可以重用它占领了。 的真空命令标志着空间 使用过期行以便重用。

过期行积聚在一个表时,必须扩展来适应新的磁盘文件 行。 性能由于增加磁盘I / O要求执行查询。 这 条件被称为_膨胀_它应该由定期吸尘表。

的真空命令\(不带完整的\)可以同时运行 与其他查询。 这标志着太空之前使用的过期是自由行。 如果 剩余数量的自由空间是重要的,它将页面添加到表的自由空间 地图。 为新行Greenplum数据库后需要空间时,它首先咨询表的 自由空间映射到发现和可用空间页面。 如果没有被发现,新的页面 附加到文件。

真空\(没有完整的\)不整合或页面 减少的尺寸表在磁盘上。 只是可以通过空间回收费 自由空间地图。 为了防止磁盘文件增长,运行是很重要的真空往往不够。 所需的频率真空运行取决于频率的更新和删除表中\(插入只添加 新行\)。 可能需要几个严重更新表真空运行/ 天,确保可用空闲空间可以通过自由空间找到地图。 它 同样重要的是运行真空在运行一个更新的事务 或删除大量的行。

的真空完整命令重写表没有过期的行,减少 表的最小大小。 每一页表中检查,可见的行 移动到页面没有完全包装。 空白页被丢弃。 表 被锁定,直到真空完整完成。 这是非常昂贵的 相比常规真空命令,可以避免或推迟 定期吸尘。 最好是运行真空完整在维护 时期。 另一种选择真空完整重新创建表的吗创建表声明中,然后删除旧表。

自由空间映射驻留在共享内存和跟踪所有表的自由空间 和索引。 每个表或索引使用大约60个字节的内存和每个页面自由空间 消耗6字节。 两个系统配置参数配置空闲空间的大小 地图:

**max\_fsm\_pages**

设置磁盘的最大数目的页面可以添加到共享自由空间地图。 6个字节的每个页面位置共享内存消耗。 默认值是200000。 这 参数必须设置至少16倍的价值

_max\_fsm\_relations_

。

**max\_fsm\_relations**

集的最大数量关系将在共享内存跟踪自由 空间映射。 这个参数应该设置为一个值大于的总数_表+索引+系统表_。 默认值是1000。 大约60个字节的 每个每段关系实例的内存消耗。 这是更好的设置 参数过高比过低。

如果自由空间映射不达标,一些磁盘页可用空间将不会被添加 地图,直到至少在未来空间不能被重用真空命令运行。 这将导致文件增长。

您可以运行真空详细的表得到一份报告, 死亡人数的段,行删除,受影响的页面数量,数量 与可用空闲空间的页面。

查询

pg\_class

系统表找出多少页表 使用的各个层次。 一定要

分析

表第一 准确的数据。

```
SELECT relname, relpages, reltuples FROM pg_class WHERE relname='
tablename
';
```

另一个有用的工具gp\_bloat\_diag视图的gp\_toolkit模式,确定了膨胀表进行比较 实际使用的表的页面数量预期的数量。 看到“gp\_toolkit 行政模式”_Greenplum数据库参考指南_更多关于gp\_bloat\_diag。

* **管理事务id的例子**
 

**父主题:**

Greenplum数据库概念

